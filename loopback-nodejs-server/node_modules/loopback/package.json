{
  "name": "loopback",
  "description": "loopback",
  "version": "0.9.0",
  "scripts": {
    "test": "mocha -R spec",
    "coverage": "mocha -r blanket -R html-cov > coverage_loopback.html"
  },
  "dependencies": {
    "debug": "latest",
    "express": "~3.1.1",
    "loopback-datasource-juggler": "git+ssh://git@github.com:strongloop/loopback-datasource-juggler.git",
    "strong-remoting": "git+ssh://git@github.com:strongloop/strong-remoting.git",
    "inflection": "~1.2.5",
    "bcrypt": "~0.7.6",
    "passport": "~0.1.17",
    "passport-local": "~0.1.6",
    "nodemailer": "~0.4.4",
    "ejs": "~0.8.4",
    "blanket": "latest",
    "mocha": "~1.8.2"
  },
  "devDependencies": {
    "mocha": "latest",
    "strong-task-emitter": "0.0.x",
    "supertest": "latest"
  },
  "readme": "# loopback\n\nv0.9.0\n\n## Install\n\n    slnode install loopback -g\n    \n## Server API\n\n - [App](#app)\n - [Model](#model)\n - [DataSource](#data-source)\n - [Connectors](#connectors)\n - [Loopback Types](#loopback-types)\n  - [GeoPoint](#geo-point)\n - [REST Router](#rest-router)\n - [Bundled Models](#bundled-models)\n  - [User](#user-model)\n  - [Session](#session-model) \n  - [Email](#email-model)\n\n## Client API\n\n_TODO_\n\n### App\n\nCreate a Loopback application.\n\n    var loopback = require('loopback');\n    var app = loopback();\n\n    app.get('/', function(req, res){\n      res.send('hello world');\n    });\n\n    app.listen(3000);\n    \n**Notes:**\n\n - extends [express](http://expressjs.com/api.html#express)\n - see [express docs](http://expressjs.com/api.html) for details\n - supports [express / connect middleware](http://expressjs.com/api.html#middleware) \n\n#### app.model(Model)\n\nExpose a `Model` to remote clients.\n\n    // create a testing data source\n    var memory = loopback.memory();\n    var Color = memory.createModel('color', {name: String});\n    Color.attachTo(memory);\n\n    app.model(Color);\n    app.use(loopback.rest());\n    \n**Note:** this will expose all [shared methods](#shared-methods) on the model.\n    \n#### app.models()\n\nGet the app's exposed models.\n\n    var models = app.models();\n    \n    models.forEach(function (Model) {\n      console.log(Model.modelName); // color\n    });\n    \n#### app.docs(options)\n\nEnable swagger REST api documentation.\n\n**Options**\n\n - `basePath` The basepath for your API - eg. 'http://localhost:3000'.\n\n**Example**\n   \n    // enable docs\n    app.docs({basePath: 'http://localhost:3000'});\n    \nRun your app then navigate to [the api explorer](http://petstore.swagger.wordnik.com/). Enter your API basepath to view your generated docs.\n    \n### Model\n\nA Loopback `Model` is a vanilla JavaScript class constructor with an attached set of properties and options. A `Model` instance is created by passing a data object containing properties to the `Model` constructor. A `Model` constructor will clean the object passed to it and only set the values matching the properties you define.\n\n    // valid color\n    var Color = loopback.createModel('color', {name: String});\n    var red = new Color({name: 'red'});\n    console.log(red.name); // red\n    \n    // invalid color\n    var foo = new Color({bar: 'bat baz'});\n    console.log(foo.bar); // undefined\n\n**Properties**\n\nA model defines a list of property names, types and other validation metadata. A [DataSource](#data-source) uses this definition to validate a `Model` during operations such as `save()`.\n\n**Options**\n\nSome [DataSources](#data-source) may support additional `Model` options.\n\nDefine A Loopbackmodel.\n\n    var User = loopback.createModel('user', {\n      first: String,\n      last: String,\n      age: Number\n    });\n\n### Validation (expiremental)\n\n#### Model.validatesFormatOf(property, options)\n\nRequire a model to include a property that matches the given format.\n\n    User.validatesFormat('name', {with: /\\w+/});\n\n#### Model.validatesPresenceOf(properties...)\n\nRequire a model to include a property to be considered valid.\n\n    User.validatesPresenceOf('first', 'last', 'age');\n\n#### Model.validatesLengthOf(property, options)\n\nRequire a property length to be within a specified range.\n\n    User.validatesLengthOf('password', {min: 5, message: {min: 'Password is too short'}});\n\n#### Model.validatesInclusionOf(property, options)\n\nRequire a value for `property` to be in the specified array.\n\n    User.validatesInclusionOf('gender', {in: ['male', 'female']});\n\n#### Model.validatesExclusionOf(property, options)\n\nRequire a value for `property` to not exist in the specified array.\n\n    User.validatesExclusionOf('domain', {in: ['www', 'billing', 'admin']});\n\n#### Model.validatesNumericalityOf(property, options)\n\nRequire a value for `property` to be a specific type of `Number`.\n\n    User.validatesNumericalityOf('age', {int: true});\n\n#### Model.validatesUniquenessOf(property, options)\n\nEnsure the value for `property` is unique in the collection of models.\n\n    User.validatesUniquenessOf('email', {message: 'email is not unique'});\n\n**Note:** not available for all [connectors](#connectors).\n\nCurrently supported in these connectors:\n\n - [In Memory](#memory-connector)\n - [Oracle](http://github.com/strongloop/loopback-connector-oracle)\n - [MongoDB](http://github.com/strongloop/loopback-connector-mongodb)\n\n#### myModel.isValid()\n\nValidate the model instance.\n\n    user.isValid(function (valid) {\n        if (!valid) {\n            user.errors // hash of errors {attr: [errmessage, errmessage, ...], attr: ...}    \n        }\n    });\n\n#### Model.properties\n\nAn object containing a normalized set of properties supplied to `loopback.createModel(name, properties)`.\n\nExample:\n\n    var props = {\n      a: String,\n      b: {type: 'Number'},\n      c: {type: 'String', min: 10, max: 100},\n      d: Date,\n      e: loopback.GeoPoint\n    };\n\n    var MyModel = loopback.createModel('foo', props);\n\n    console.log(MyModel.properties);\n    \nOutputs:\n\n    {\n      \"a\": {type: String},\n      \"b\": {type: Number},\n      \"c\": {\n        \"type\": String,\n        \"min\": 10,\n        \"max\": 100\n      },\n      \"d\": {type: Date},\n      \"e\": {type: GeoPoint},\n      \"id\": {\n        \"id\": 1\n      }\n    }\n\n#### Model.attachTo(dataSource)\n\nAttach a model to a [DataSource](#data-source). Attaching a [DataSource](#data-source) updates the model with additional methods and behaviors.\n\n    var oracle = loopback.createDataSource({\n      connector: require('loopback-connector-oracle'),\n      host: '111.22.333.44',\n      database: 'MYDB',\n      username: 'username',\n      password: 'password'\n    });\n\n    User.attachTo(oracle);\n    \n**Note:** until a model is attached to a data source it will **not** have any **attached methods**.\n\n#### CRUD and Query Mixins\n\nMixins are added by attaching a vanilla model to a [data source](#data-source) with a [connector](#connectors). Each [connector](#connectors) enables its own set of operations that are mixed into a `Model` as methods. To see available methods for a data source call `dataSource.operations()`.\n\nLog the available methods for a memory data source.\n\n    var ops = loopback\n        .createDataSource({connector: loopback.Memory})\n        .operations();\n    \n    console.log(Object.keys(ops));\n    \nOutputs:\n\n    [ 'create',\n      'updateOrCreate',\n      'upsert',\n      'findOrCreate',\n      'exists',\n      'findById',\n      'find',\n      'all',\n      'findOne',\n      'destroyAll',\n      'deleteAll',\n      'count',\n      'include',\n      'relationNameFor',\n      'hasMany',\n      'belongsTo',\n      'hasAndBelongsToMany',\n      'save',\n      'isNewRecord',\n      'destroy',\n      'delete',\n      'updateAttribute',\n      'updateAttributes',\n      'reload' ]\n      \nHere is the definition of the `count()` operation.\n\n    {\n      accepts: [ { arg: 'where', type: 'object' } ],\n      http: { verb: 'get', path: '/count' },\n      remoteEnabled: true,\n      name: 'count'\n    }\n\n#### Static Methods\n\n**Note:** These are the default mixin methods for a `Model` attached to a data source. See the specific connector for additional API documentation.\n\n##### Model.create(data, [callback])\n\nCreate an instance of Model with given data and save to the attached data source. Callback is optional.\n\n    User.create({first: 'Joe', last: 'Bob'}, function(err, user) {\n      console.log(user instanceof User); // true\n    });\n    \n**Note:** You must include a callback and use the created model provided in the callback if your code depends on your model being saved or having an `id`.\n\n##### Model.count([query], callback)\n\nQuery count of Model instances in data source. Optional query param allows to count filtered set of Model instances.\n\n    User.count({approved: true}, function(err, count) {\n      console.log(count); // 2081\n    });\n\n##### Model.find(filter, callback)\n\nFind all instances of Model, matched by query. Fields used for filter and sort should be declared with `{index: true}` in model definition.\n\n**filter**\n\n - **where** `Object` { key: val, key2: {gt: 'val2'}}\n - **include** `String`, `Object` or `Array`.\n - **order** `String`\n - **limit** `Number`\n - **skip** `Number`\n - **fields** `Object|Array|String`\n  - `['foo']` or `'foo'` - include only the foo property \n  - `['foo', 'bar']` - include the foo and bar properties\n  - `{foo: true}` - include only foo\n  - `{bat: false}` - include all properties, exclude bat\n\nFind the second page of 10 users over age 21 in descending order exluding the password property.\n\n    User.find({\n      where: {\n        age: {gt: 21}},\n        order: 'age DESC',\n        limit: 10,\n        skip: 10,\n        fields: {password: false}\n      },\n      console.log\n    );\n\n**Note:** See the specific connector's [docs](#connectors) for more info.\n\n##### Model.destroyAll(callback)\n\nDelete all Model instances from data source. **Note:** destroyAll method does not perform destroy hooks.\n\n##### Model.findById(id, callback)\n\nFind instance by id.\n\n    User.findById(23, function(err, user) {\n      console.info(user.id); // 23\n    });\n\n##### Model.findOne(where, callback)\n\nFind a single instance that matches the given where expression.\n\n    User.findOne({id: 23}, function(err, user) {\n      console.info(user.id); // 23\n    });\n    \n##### Model.upsert(data, callback)\n\nUpdate when record with id=data.id found, insert otherwise. **Note:** no setters, validations or hooks applied when using upsert.\n\n##### Custom Static Methods\n\nDefine a static model method.\n\n    User.login = function (username, password, fn) {\n      var passwordHash = hashPassword(password);\n      this.findOne({username: username}, function (err, user) {\n        var failErr = new Error('login failed');\n    \n        if(err) {\n          fn(err);\n        } else if(!user) {\n          fn(failErr);\n        } else if(user.password === passwordHash) {\n          MySessionModel.create({userId: user.id}, function (err, session) {\n            fn(null, session.id);\n          });\n        } else {\n          fn(failErr);\n        }\n      });\n    }\n    \nSetup the static model method to be exposed to clients as a [remote method](#remote-method). \n\n    loopback.remoteMethod(\n      User.login,\n      {\n        accepts: [\n          {arg: 'username', type: 'string', required: true},\n          {arg: 'password', type: 'string', required: true}\n        ],\n        returns: {arg: 'sessionId', type: 'any'},\n        http: {path: '/sign-in'}\n      }\n    );\n    \n#### Instance Methods\n\n**Note:** These are the default mixin methods for a `Model` attached to a data source. See the specific connector for additional API documentation.\n\n##### model.save([options], [callback])\n\nSave an instance of a Model to the attached data source.\n\n    var joe = new User({first: 'Joe', last: 'Bob'});\n    joe.save(function(err, user) {\n      if(user.errors) {\n        console.log(user.errors);\n      } else {\n        console.log(user.id);\n      }\n    });\n\n##### model.updateAttributes(data, [callback])\n    \nSave specified attributes to the attached data source.\n\n    user.updateAttributes({\n      first: 'updatedFirst',\n      name: 'updatedLast'\n    }, fn);\n\n##### model.destroy([callback])\n\nRemove a model from the attached data source.\n\n    model.destroy(function(err) {\n      // model instance destroyed\n    });\n\n##### Custom Instance Methods\n\nDefine an instance method.\n\n    User.prototype.logout = function (fn) {\n      MySessionModel.destroyAll({userId: this.id}, fn);\n    }\n    \nDefine a remote model instance method.\n\n    loopback.remoteMethod(User.prototype.logout);\n\n#### Remote Methods\n\nBoth instance and static methods can be exposed to clients. A remote method must accept a callback with the conventional `fn(err, result, ...)` signature. \n\n##### loopback.remoteMethod(fn, [options]);\n\nExpose a remote method.\n\n    Product.stats = function(fn) {\n      var calc = require('./stats');\n      \n      Product.find(function(err, products) {\n        var productStats = calc(products);\n        fn(null, productStats);\n      });\n    }\n    \n    loopback.remoteMethod(\n      Product.stats,\n      {\n        returns: {arg: 'stats', type: 'object'},\n        http: {path: '/info', verb: 'get'}\n      }\n    );\n\n**Options**\n\n - **accepts** - (optional) an arguments description specifying the remote method's arguments. A\n - **returns** - (optional) an arguments description specifying the remote methods callback arguments.\n - **http** - (advanced / optional, object) http routing info\n  - **http.path** - the path relative to the model the method will be exposed at. May be a path fragment (eg. '/:myArg') which will be populated by an arg of the same name in the accepts description. For example the stats method above will be at the whole path `/products/stats`.\n  - **http.verb** - (get, post, put, del, all) - the route verb the method will be available from.\n \n**Argument Description**\n\nAn arguments description defines either a single argument as an object or an ordered set of arguments as an array.\n\n    // examples\n    {arg: 'myArg', type: 'number'}\n\n    [\n      {arg: 'arg1', type: 'number', required: true},\n      {arg: 'arg2', type: 'array'}\n    ]\n\n**Types**\n\nEach argument may define any of the [loopback types](#loopback-types).\n\n**Notes:**\n\n  - The callback is an assumed argument and does not need to be specified in the accepts array.\n  - The err argument is also assumed and does not need to be specified in the returns array.\n\n#### Remote Hooks\n\nRun a function before or after a remote method is called by a client.\n\n    // *.save === prototype.save\n    User.beforeRemote('*.save', function(ctx, user, next) {\n      if(ctx.user) {\n        next();\n      } else {\n        next(new Error('must be logged in to update'))\n      }\n    });\n    \n    User.afterRemote('*.save', function(ctx, user, next) {\n      console.log('user has been saved', user);\n      next();\n    });\n    \nRemote hooks also support wildcards. Run a function before any remote method is called.\n\n    // ** will match both prototype.* and *.*\n    User.beforeRemote('**', function(ctx, user, next) {\n      console.log(ctx.methodString, 'was invoked remotely'); // users.prototype.save was invoked remotely\n      next();\n    });\n    \nOther wildcard examples\n\n    // run before any static method eg. User.find\n    User.beforeRemote('*', ...);\n    \n    // run before any instance method eg. User.prototype.save\n    User.beforeRemote('prototype.*', ...);\n    \n    // prevent password hashes from being sent to clients\n    User.afterRemote('**', function (ctx, user, next) {\n      if(ctx.result) {\n        if(Array.isArray(ctx.result)) {\n          ctx.result.forEach(function (result) {\n            result.password = undefined;\n          });\n        } else {\n          ctx.result.password = undefined;\n        }\n      }\n  \n      next();\n    });\n    \n#### Context\n\nRemote hooks are provided with a Context `ctx` object which contains transport specific data (eg. for http: `req` and `res`). The `ctx` object also has a set of consistent apis across transports.\n\n##### ctx.user\n\nA `Model` representing the user calling the method remotely. **Note:** this is undefined if the remote method is not invoked by a logged in user.\n\n##### ctx.result\n\nDuring `afterRemote` hooks, `ctx.result` will contain the data about to be sent to a client. Modify this object to transform data before it is sent. \n\n##### Rest\n\nWhen [loopback.rest](#loopbackrest) is used the following `ctx` properties are available.\n\n###### ctx.req\n\nThe express ServerRequest object. [See full documentation](http://expressjs.com/api.html#req).\n\n###### ctx.res\n\nThe express ServerResponse object. [See full documentation](http://expressjs.com/api.html#res).\n\nAccess the raw `req` object for the remote method call.\n    \n#### Relationships\n\n##### Model.hasMany(Model)\n\nDefine a \"one to many\" relationship.\n\n    // by referencing model\n    Book.hasMany(Chapter);\n    // specify the name\n    Book.hasMany('chapters', {model: Chapter});\n    \nQuery and create the related models.\n\n    Book.create(function(err, book) {\n      // create a chapter instance\n      // ready to be saved in the data source\n      var chapter = book.chapters.build({name: 'Chapter 1'});\n      \n      // save the new chapter\n      chapter.save();\n      \n      // you can also call the Chapter.create method with\n      // the `chapters` property which will build a chapter\n      // instance and save the it in the data source\n      book.chapters.create({name: 'Chapter 2'}, function(err, savedChapter) {\n        // this callback is optional\n      });\n\n      // query chapters for the book using the \n      book.chapters(function(err, chapters) {\n        // all chapters with bookId = book.id\n        console.log(chapters);\n      });\n      \n      book.chapters({where: {name: 'test'}, function(err, chapters) {\n        // all chapters with bookId = book.id and name = 'test'\n        console.log(chapters);\n      });\n    });\n    \n#### Shared Methods\n\nAny static or instance method can be decorated as `shared`. These methods are exposed over the provided transport (eg. [loopback.rest](#rest)).\n\n### Data Source\n\nA Loopback `DataSource` provides [Models](#model) with the ability to manipulate data. Attaching a `DataSource` to a `Model` adds [instance methods](#instance-methods) and [static methods](#static-methods) to the `Model`. The added methods may be [remote methods](#remote-methods).\n\nDefine a data source for persisting models.\n\n    var oracle = loopback.createDataSource({\n      connector: 'oracle',\n      host: '111.22.333.44',\n      database: 'MYDB',\n      username: 'username',\n      password: 'password'\n    });\n    \n#### dataSource.createModel(name, properties, options)\n\nDefine a model and attach it to a `DataSource`.\n\n    var Color = oracle.createModel('color', {name: String});\n\n#### dataSource.discoverModelDefinitions([username], fn)\n\nDiscover a set of model definitions (table or collection names) based on tables or collections in a data source.\n\n    oracle.discoverModelDefinitions(function (err, models) {\n      models.forEach(function (def) {\n        // def.name ~ the model name\n        oracle.discoverSchema(null, def.name, function (err, schema) {\n          console.log(schema);\n        });\n      });\n    });\n    \n#### dataSource.discoverSchema([owner], name, fn)\n\nDiscover the schema of a specific table or collection.\n\n**Example schema from oracle connector:**\n\n    {\n      \"name\": \"Product\",\n      \"options\": {\n        \"idInjection\": false,\n        \"oracle\": {\n          \"schema\": \"BLACKPOOL\",\n          \"table\": \"PRODUCT\"\n        }\n      },\n      \"properties\": {\n        \"id\": {\n          \"type\": \"String\",\n          \"required\": true,\n          \"length\": 20,\n          \"id\": 1,\n          \"oracle\": {\n            \"columnName\": \"ID\",\n            \"dataType\": \"VARCHAR2\",\n            \"dataLength\": 20,\n            \"nullable\": \"N\"\n          }\n        },\n        \"name\": {\n          \"type\": \"String\",\n          \"required\": false,\n          \"length\": 64,\n          \"oracle\": {\n            \"columnName\": \"NAME\",\n            \"dataType\": \"VARCHAR2\",\n            \"dataLength\": 64,\n            \"nullable\": \"Y\"\n          }\n        },\n        \"audibleRange\": {\n          \"type\": \"Number\",\n          \"required\": false,\n          \"length\": 22,\n          \"oracle\": {\n            \"columnName\": \"AUDIBLE_RANGE\",\n            \"dataType\": \"NUMBER\",\n            \"dataLength\": 22,\n            \"nullable\": \"Y\"\n          }\n        },\n        \"effectiveRange\": {\n          \"type\": \"Number\",\n          \"required\": false,\n          \"length\": 22,\n          \"oracle\": {\n            \"columnName\": \"EFFECTIVE_RANGE\",\n            \"dataType\": \"NUMBER\",\n            \"dataLength\": 22,\n            \"nullable\": \"Y\"\n          }\n        },\n        \"rounds\": {\n          \"type\": \"Number\",\n          \"required\": false,\n          \"length\": 22,\n          \"oracle\": {\n            \"columnName\": \"ROUNDS\",\n            \"dataType\": \"NUMBER\",\n            \"dataLength\": 22,\n            \"nullable\": \"Y\"\n          }\n        },\n        \"extras\": {\n          \"type\": \"String\",\n          \"required\": false,\n          \"length\": 64,\n          \"oracle\": {\n            \"columnName\": \"EXTRAS\",\n            \"dataType\": \"VARCHAR2\",\n            \"dataLength\": 64,\n            \"nullable\": \"Y\"\n          }\n        },\n        \"fireModes\": {\n          \"type\": \"String\",\n          \"required\": false,\n          \"length\": 64,\n          \"oracle\": {\n            \"columnName\": \"FIRE_MODES\",\n            \"dataType\": \"VARCHAR2\",\n            \"dataLength\": 64,\n            \"nullable\": \"Y\"\n          }\n        }\n      }\n    }\n\n#### dataSource.enableRemote(operation)\n\nEnable remote access to a data source operation. Each [connector](#connector) has its own set of set remotely enabled and disabled operations. You can always list these by calling `dataSource.operations()`.\n    \n\n#### dataSource.disableRemote(operation)\n\nDisable remote access to a data source operation. Each [connector](#connector) has its own set of set enabled and disabled operations. You can always list these by calling `dataSource.operations()`.\n\n    // all rest data source operations are\n    // disabled by default\n    var oracle = loopback.createDataSource({\n      connector: require('loopback-connector-oracle'),\n      host: '...',\n      ...\n    });\n    \n    // or only disable it as a remote method\n    oracle.disableRemote('destroyAll');\n\n**Notes:**\n\n - disabled operations will not be added to attached models\n - disabling the remoting for a method only affects client access (it will still be available from server models)\n - data sources must enable / disable operations before attaching or creating models\n\n#### dataSource.operations()\n\nList the enabled and disabled operations.\n\n    console.log(oracle.operations());\n    \nOutput:\n\n    {\n      find: {\n        remoteEnabled: true,\n        accepts: [...],\n        returns: [...]\n        enabled: true\n      },\n      save: {\n        remoteEnabled: true,\n        prototype: true,\n        accepts: [...],\n        returns: [...],\n        enabled: true\n      },\n      ...\n    }\n\n#### Connectors\n\nCreate a data source with a specific connector. See **available connectors** for specific connector documentation. \n\n    var memory = loopback.createDataSource({\n      connector: loopback.Memory\n    });\n    \n**Available Connectors**\n \n - [In Memory](#memory-connector)\n - [REST](http://github.com/strongloop/loopback-connector-rest)\n - [Oracle](http://github.com/strongloop/loopback-connector-oracle)\n - [MongoDB](http://github.com/strongloop/loopback-connector-mongodb)\n - TODO - [MySQL](http://github.com/strongloop/loopback-connector-mysql)\n - TODO - [SQLite3](http://github.com/strongloop/loopback-connector-sqlite)\n - TODO - [Postgres](http://github.com/strongloop/loopback-connector-postgres)\n - TODO - [Redis](http://github.com/strongloop/loopback-connector-redis)\n - TODO - [CouchDB](http://github.com/strongloop/loopback-connector-couch)\n - TODO - [Firebird](http://github.com/strongloop/loopback-connector-firebird)\n\n**Installing Connectors**\n\nInclude the connector in your package.json dependencies and run `npm install`.\n\n    {\n      \"dependencies\": {\n        \"loopback-connector-oracle\": \"latest\"\n      }\n    }\n\n##### Memory Connector\n\nThe built-in memory connector allows you to test your application without connecting to an actual persistent data source, such as a database. Although the memory connector is very well tested it is not recommended to be used in production. Creating a data source using the memory connector is very simple.\n\n    // use the built in memory function\n    // to create a memory data source\n    var memory = loopback.memory();\n\n    // or create it using the standard\n    // data source creation api\n    var memory = loopback.createDataSource({\n      connector: loopback.Memory\n    });\n    \n    // create a model using the\n    // memory data source\n    var properties = {\n      name: String,\n      price: Number\n    };\n    \n    var Product = memory.createModel('product', properties);\n    \n    Product.create([\n      {name: 'apple', price: 0.79},\n      {name: 'pear', price: 1.29},\n      {name: 'orange', price: 0.59},\n    ], count);\n    \n    function count() {\n      Product.count(console.log); // 3\n    }\n\n###### Operations\n\n**CRUD / Query**\n\nThe memory connector supports all the standard [query and crud operations](#crud-and-query-mixins) to allow you to test your models against an in memory data source.\n\n**GeoPoint Filtering**\n\nThe memory connector also supports geo-filtering when using the `find()` operation with an attached model. See [GeoPoint](#geopoint) for more information on geo-filtering.\n\n### GeoPoint\n\nUse the `GeoPoint` class.\n\n    var GeoPoint = require('loopback').GeoPoint;\n\nEmbed a latitude / longitude point in a [Model](#model).\n\n    var CoffeeShop = loopback.createModel('coffee-shop', {\n      location: 'GeoPoint'\n    });\n\nLoopback Model's with a GeoPoint property and an attached DataSource may be queried using geo spatial filters and sorting.\n\nFind the 3 nearest coffee shops.\n\n    CoffeeShop.attachTo(oracle);\n    var here = new GeoPoint({lat: 10.32424, lng: 5.84978});\n    CoffeeShop.find({where: {location: {near: here}}, limit:3}, function(err, nearbyShops) {\n      console.info(nearbyShops); // [CoffeeShop, ...]\n    });\n\n#### geoPoint.distanceTo(geoPoint, options)\n\nGet the distance to another `GeoPoint`.\n\n    var here = new GeoPoint({lat: 10, lng: 10});\n    var there = new GeoPoint({lat: 5, lng: 5});\n    console.log(here.distanceTo(there, {type: 'miles'})); // 438\n \n#### GeoPoint.distanceBetween(a, b, options)\n\nGet the distance between two points.\n\n    GeoPoint.distanceBetween(here, there, {type: 'miles'}) // 438\n\n#### Distance Types\n\n**Note:** all distance methods use `miles` by default.\n\n - `miles`\n - `radians`\n - `kilometers`\n - `meters`\n - `miles`\n - `feet`\n - `degrees`\n\n#### geoPoint.lat\n\nThe latitude point in degrees. Range: -90 to 90.\n\n#### geoPoint.lng\n\nThe longitude point in degrees. Range: -180 to 180.\n\n### Loopback Types\n\nVarious APIs in Loopback accept type descriptions (eg. [remote methods](#remote-methods), [loopback.createModel()](#model)). The following is a list of supported types.\n\n - `null` - JSON null\n - `Boolean` - JSON boolean\n - `Number` - JSON number\n - `String` - JSON string\n - `Object` - JSON object\n - `Array` - JSON array\n - `Date` - a JavaScript date object\n - `Buffer` - a node.js Buffer object\n - [GeoPoint](#geopoint) - A Loopback GeoPoint object.\n\n## Bundled Models\n\nThe Loopback library is unopinioned in the way you define your app's data and logic. Loopback also bundles useful pre-built models for common use cases.\n\n - User - register and authenticate users of your app locally or against 3rd party services.\n - Email - send emails to your app users using smtp or 3rd party services.\n\nDefining a model with `loopback.createModel()` is really just extending the base `loopback.Model` type using `loopback.Model.extend()`. The bundled models extend from the base `loopback.Model` allowing you to extend them arbitrarily.\n \n### User Model\n\nRegister and authenticate users of your app locally or against 3rd party services.\n\n#### Define a User Model\n\nExtend a vanilla Loopback model using the built in User model.\n\n    // create a data source\n    var memory = loopback.memory();\n \n    // define a User model\n    var User = loopback.User.extend('user');\n  \n    // attach to the memory connector\n    User.attachTo(memory);\n    \n    // also attach the session model to a data source\n    User.session.attachTo(memory);\n    \n    // expose over the app's api\n    app.model(User);\n    \n**Note:** By default the `loopback.User` model uses the `loopback.Session` model to persist sessions. You can change this by setting the `session` property.\n\n**Note:** You must attach both the `User` and `User.session` model's to a data source!\n    \n#### User Creation\n\nCreate a user like any other model.\n\n    // username and password are not required\n    User.create({email: 'foo@bar.com', password: 'bar'}, function(err, user) {\n      console.log(user);\n    });\n\n    \n#### Login a User\n\nCreate a session for a user using the local auth strategy.\n\n**Node.js**\n\n    User.login({username: 'foo', password: 'bar'}, function(err, session) {\n      console.log(session);\n    });\n    \n**REST**\n\nYou must provide a username and password over rest. To ensure these values are encrypted, include these as part of the body and make sure you are serving your app over https (through a proxy or using the https node server).\n\n    POST\n\n      /users/login\n      ...\n      {\n        \"email\": \"foo@bar.com\",\n        \"password\": \"bar\"\n      }\n  \n      ...\n  \n      200 OK\n      {\n        \"sid\": \"1234abcdefg\",\n        \"uid\": \"123\"\n      }\n\n#### Logout a User\n\n**Node.js**\n\n    // login a user and logout\n    User.login({\"email\": \"foo@bar.com\", \"password\": \"bar\"}, function(err, session) {\n      User.logout(session.id, function(err) {\n        // user logged out\n      });\n    });\n\n    // logout a user (server side only)\n    User.findOne({email: 'foo@bar.com'}, function(err, user) {\n      user.logout();\n    });\n    \n**REST**\n\n    POST /users/logout\n    ...\n    {\n      \"sid\": \"<session id from user login>\"\n    }\n\n#### Verify Email Addresses\n\nRequire a user to verify their email address before being able to login. This will send an email to the user containing a link to verify their address. Once the user follows the link they will be redirected to `/` and be able to login normally.\n\n    User.requireEmailVerfication = true;\n    User.afterRemote('create', function(ctx, user, next) {\n      var options = {\n        type: 'email',\n        to: user.email,\n        from: 'noreply@myapp.com',\n        subject: 'Thanks for Registering at FooBar',\n        text: 'Please verify your email address!'\n        template: 'verify.ejs',\n        redirect: '/'\n      };\n      \n      user.verify(options, next);\n    });\n    \n\n#### Send Reset Password Email\n\nSend an email to the user's supplied email address containing a link to reset their password.\n  \n    User.reset(email, function(err) {\n      console.log('email sent');\n    });\n    \n#### Remote Password Reset\n\nThe password reset email will send users to a page rendered by loopback with fields required to reset the user's password. You may customize this template by defining a `resetTemplate` setting.\n\n    User.settings.resetTemplate = 'reset.ejs';\n    \n#### Remote Password Reset Confirmation\n\nConfirm the password reset.\n\n    User.confirmReset(token, function(err) {\n      console.log(err || 'your password was reset');\n    });\n\n\n### Session Model\n\nIdentify users by creating sessions when they connect to your loopback app. By default the `loopback.User` model uses the `loopback.Session` model to persist sessions. You can change this by setting the `session` property.\n\n    // define a custom session model    \n    var MySession = loopback.Session.extend('my-session');\n    \n    // define a custom User model\n    var User = loopback.User.extend('user');\n    \n    // use the custom session model\n    User.session = MySession;\n    \n    // attach both Session and User to a data source\n    User.attachTo(loopback.memory());\n    MySession.attachTo(loopback.memory());\n    \n### Email Model\n\nSend emails from your loopback app.\n\n### REST Router\n\nExpose models over rest using the `loopback.rest` router.\n\n    app.use(loopback.rest());\n    \n**REST Documentation**\n\nView generated REST documentation by visiting: [http://localhost:3000/_docs](http://localhost:3000/_docs).\n    \n### SocketIO Middleware (Not Available)\n\n**Coming Soon** - Expose models over socket.io using the `loopback.sio()` middleware.\n\n    app.use(loopback.sio);\n    \n",
  "readmeFilename": "README.md",
  "_id": "loopback@0.9.0",
  "dist": {
    "shasum": "efb00ed3a9cf95f723c2bb8f6c8f46721dcc4021"
  },
  "_resolved": "git+ssh://git@github.com/strongloop/loopback.git#e3e6e9f1ff8411340dc51fa58ea5b056348b9422",
  "_from": "loopback@git+ssh://git@github.com/strongloop/loopback.git"
}
